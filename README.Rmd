---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "##",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# pgIRT

<!-- badges: start -->
<!-- badges: end -->

`pgIRT` is an **R** package that implements Item Response Theory (IRT) model with Polya-Gamma data augmentation and EM Algorithm. The implementation includes binary and multinomial along with dynamic IRT models. The algorithm here is based on the procedure proposed by Goplerud (2019). This package also utilizes the parametric bootstrap method proposed by Lewis and Poole (2004) to estimate confidence interval.

## Installation

You can install the development version of pgIRT from [GitHub](https://github.com) with:

``` r
remotes::install_github("vkyo23/pgIRT")
```
## Usage

### Binary IRT

Using `Senate` data from `MCMCpack`. 

```{r}
library(pgIRT)
require(dplyr)
require(tidyr)

data(Senate, package = "MCMCpack")
mat <- as.matrix(Senate[, 6:ncol(Senate)])
colnames(mat) <- 1:ncol(mat)
rownames(mat) <- 1:nrow(mat)

# `make_init` is an auxiliary function which computes initial values for `pgIRT`.
init <- make_init(mat, model = "bin")
fit <- pgIRT(mat, 
             model = "bin",
             init = init,
             verbose = 20)

summary(fit, parameter = "theta")
```

### Dynamic binary IRT

Using `Rehnquist` data from `MCMCpack`. To introduce some auxiliary function of `pgIRT`, I fisrt construct long-format dataframe.

```{r}
# Convert into long-format dataframe
data(Rehnquist, package = "MCMCpack")
long_df <- Rehnquist %>% 
  mutate(rcid = row_number()) %>% 
  select(-term) %>% 
  mutate(time = time - min(time)) %>% 
  pivot_longer(-c(time, rcid))
jname <- tibble(name = unique(long_df$name)) %>% 
  mutate(judge_id = row_number())
long_df <- long_df %>% 
  left_join(jname, by = "name")
head(long_df) %>% 
  knitr::kable()
```


```{r}
# Generating roll-call matrix from long-format dataframe
mat_dyn <- make_rollcall(long_df, 
                         unit_id = "judge_id", 
                         bill_id = "rcid",
                         vote_col = "value")

# Initial values
constraint_dyn <- jname$judge_id[jname$name == "Thomas"]
init_dyn <- make_init(mat_dyn,
                      model = "bin_dyn",
                      T = length(unique(long_df$time)),
                      constraint = constraint_dyn)

# Generating options for dynamic estimation
dyn_ops <- make_dyn_options(long_df,
                            unit_id = "judge_id",
                            bill_id = "rcid",
                            time_id = "time",
                            vote_col = "value")

# IRT
fit_dyn <- pgIRT(mat_dyn,
             model = "bin_dyn",
             init = init_dyn,
             constraint = constraint_dyn,
             dyn_options = dyn_ops,
             verbose = 20)
```

To compute confidence interval, run bootstrap via `pgIRT_boot`:

```{r}
# Bootstrap
boot <- pgIRT_boot(fit_dyn, boot = 100, verbose = 20)

summary(boot, parameter = "theta", ci = .95)
```


### Multinomial IRT

Using a simulated voting data `m_data`.

```{r}
data("m_data")

init_mlt <- make_init(m_data,
                      model = "multi")
fit_mlt <- pgIRT(m_data,
                 model = "multi",
                 init = init_mlt, 
                 constraint = 1,
                 verbose = 20)

summary(fit_mlt, parameter = c("alpha", "beta"))
```


### Dynamic multinomial IRT

Using a simulated voting data (long-format dataframe) `m_data_dyn` and a simulated matching bill data `sim_match` for dynamic estimation (See more detail of across time estimation in Bailey (2007)).

```{r}
# multinomial dynamic
data("m_data_dyn")
data("sim_match")

m_mlt_d <- make_rollcall(m_data_dyn,
                         unit_id = "unit",
                         bill_id = "bill",
                         vote_col = "vote",
                         drop_unanimous = TRUE)

# Generating matching bill indicator for across time estimation
bill_match <- make_bill_match(m_mlt_d, sim_match)
init_mlt_d <- make_init(m_mlt_d, 
                        model = "multi_dyn",
                        T = length(unique(m_data_dyn$time)),
                        bill_match = bill_match,
                        constraint = 1)

dyn_ops_mlt <- make_dyn_options(m_data_dyn,
                                unit_id = "unit",
                                bill_id = "bill",
                                time_id = "time",
                                vote_col = "vote",
                                bill_match = bill_match,
                                drop_unanimous = TRUE)

fit_mlt_d <- pgIRT(m_mlt_d,
                   mode = "multi_dyn",
                   init = init_mlt_d,
                   constraint = 1,
                   dyn_options = dyn_ops_mlt,
                   verbose = 20)
```

Returning 99% confidence interval:

```{r}
boot_mlt_d <- pgIRT_boot(fit_mlt_d, boot = 100, verbose = 20)

summary(boot_mlt_d, parameter = "theta", ci = .99)
```


## References

+ Bailey, M. A. (2007). "Comparable preference estimates across time and institutions for the court, congress, and presidency". *American Journal of Political Science*, 51(3), 433-448.
+ Goplerud, M. (2019). "A Multinomial Framework for Ideal Point Estimation". *Political Analysis*, 27(1), 69-89.
+ Lewis, J. B., & Poole, K. T. (2004). "Measuring bias and uncertainty in ideal point estimates via the parametric bootstrap". *Political Analysis*, 12(2), 105-127.
+ Martin A.D., Quinn K.M. & Park J.H. (2011). "MCMCpack: Markov Chain Monte Carlo in R." *Journal of Statistical Software*, 42(9), 22.
